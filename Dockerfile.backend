# Shared Dockerfile for backend services

# 1. Stage: Install dependencies
# This stage installs all npm dependencies. It's a separate stage to leverage Docker's caching.
# It only re-runs if the package.json or package-lock.json files change.
FROM node:18-alpine AS dependencies

# Set the working directory
WORKDIR /usr/src/app

# Copy all package.json and package-lock.json files from the monorepo
# A wildcard is used for package-lock.json to handle cases where it might not exist initially.
COPY package.json package-lock.json* ./
COPY apps/components/package.json ./apps/components/
COPY apps/stores/package.json ./apps/stores/
COPY apps/web-client/package.json ./apps/web-client/
COPY packages/common/package.json ./packages/common/
COPY services/auth-service/package.json ./services/auth-service/
COPY services/crm-service/package.json ./services/crm-service/
COPY services/sales-service/package.json ./services/sales-service/

# Explicitly unset any proxy settings that might be inherited from the host environment.
RUN npm config delete proxy
RUN npm config delete https-proxy
# Set the registry to a reliable public mirror to bypass network issues.
RUN npm config set registry https://registry.npmmirror.com/

# Install dependencies using 'npm install'.
# --legacy-peer-deps is used to avoid issues with peer dependency conflicts.
RUN npm install --legacy-peer-deps

# 2. Stage: Build the application
# This stage builds the specific service.
FROM node:18-alpine AS builder

# Argument to specify which service to build
ARG SERVICE_NAME

WORKDIR /usr/src/app

# Copy the entire monorepo source code first.
COPY . .

# Now, copy the clean, correctly-installed node_modules from the 'dependencies' stage.
COPY --from=dependencies /usr/src/app/node_modules ./node_modules

# Build the specified service using the direct path to the executable.
# This is the most reliable method and avoids potential npx/shell path issues.
RUN /usr/src/app/node_modules/.bin/nest build ${SERVICE_NAME}

# 3. Stage: Production image
# This is the final, lightweight image that will be run.
FROM node:18-alpine AS runner

# Argument to specify which service this container is for
ARG SERVICE_NAME

WORKDIR /usr/src/app

# Create a non-root user and group for security best practices
RUN addgroup -S appgroup && adduser -S appuser -G appgroup

# Copy only the necessary production dependencies from the 'dependencies' stage
COPY --from=dependencies /usr/src/app/node_modules ./node_modules
# Copy the built application from the 'builder' stage.
# For a NestJS monorepo, the output is in a subfolder within dist.
COPY --from=builder /usr/src/app/dist/services/${SERVICE_NAME} ./dist

# Change ownership of the app files to the non-root user
RUN chown -R appuser:appgroup /usr/src/app

# Switch to the non-root user
USER appuser

# Expose the port the app runs on
EXPOSE 3000

# The command to run the application
# It starts the built service using node.
CMD ["node", "dist/main"]
